HotSpot - ява машина 250k, sun->oracle,
Теория о поколениях - болтшинство объесктов - маложивущие: аргументы функции, катч, Integer,Long
Ост: синглтоны, аппконтекст, сервлеты
heap в основном.
Permanent generation.
Serial GC Stop the world - когда заполняется янг, потоки останавливается.
Сборщик проходит по объектам и вычисляет живые, и все живые копирует в Surviver0, затем eaden сичитается пустым.
2/3 old, 1/3 yang+Surviver, Syrviver 1/10(Young), затем проходит опять по (young & s0) ->s1. Один из сурвиверов
пуст, другой полон. Известно кол-во переходов между сурв, если много -> old generation.
stack код приложения.
Class A{
 B b;}
Class B {
 A a;} - помечаются как неживые.
 Все это - минорная сборка называется.
 Если (old gen C->A) (a<>b) они помечаюься как кандиданы в old
 Если из рута - живым объявляется.(статич контекст)
 ! Время GC, пропускная способность ta/tb, ресурсы.
 Full GC - затрагивает old generation. Спасает только рутовая ссылка. Очень дорогая операция.
 STW. Останавливается тк память копируется,...
 В олд - дефрагментация, или упорядочивание.

java -Xmx20m -cp ./ -XX:+UseSerialGC ru.innopolis.spring.JIT.Main

    Большие объекты. Если не помещяется в сурвивор - помещается в олд.

2. Parallel  отличается тем, что выполняет сбору в енсколько потоков.
STW уменьшается, ресурсы потребляются больше. В минорной сборке не отлячается, фулл быстрее.
    Фрагментация. В паралел - делится на сегменты.

3. CMS concurrent mark sweep. Более умный. Старшая и младшая сборка. Младшая=минорная.
Сраршая:
1 SWT проходит и отмечает те, у которых есть рутовая ссылка.
2 Проходит по остальным объестам, на которые есть ссылки из первых отмеченных.
3 SWT помечаются оставшиеся живые.
4 параллельно с работой производится очистка мусора во много потоков. Нет упорядочивания.Выделяется на 20%
больше памяти.

4. G1 garbage first. бересся вся память, делится на сегменты, и old and eaden
 Просматривает,в каких сегментах больше мусора, когда приходит время, очищает самые замусоренные.
 Можно логировать GC.

 Могут спросить разбиение кучи,
 Tenured - old generation. Exception: Out of memory,
  Permanent gen - постоянная инфа, тоже чистится. Класслоадер удаляется, классы тоже.
  java out of memory error pemgen space.

  Можно задавать размер. Permanent - пересмотр дорогая операция, лучше мин и макс задать.


            JIT
Just in time compilation.
jdk jre runtime enviroment - минимальная реализация для запуска. - jvm+libraries.
80% time 20%code. Hotspot searches 20% and optimize it.
Servernaya i klientskaya
2 Заголовок содержал внутреннюю ссылку. Теперь ссылки прямые. Длянна -2 worda.
Массив содержит 1 ворд - длянна массива.

3 Нативная поддержка потоков.
Переупорядочивание полей.
class Cotton {
    char color;
    int joe;
    Object mine;
    char armed;
}
class Cotton { - так
    Object mine;
    int joe;
    char armed;
    char color;
}
jit компилирует в машинный на лету.
Ограничения по ср с++
1 динамическая проверка безопастности.
2 создание объ в куче
3 все виртуальные
4 спецификация позв подгружать классы, механизм адаптивной оптимизации
 а поиск горячих мест - настраивается
 б оптимизация компилятора, инлайнинг
 в деоптимизация, если поменяли поведение класса
 клиентский нацелен на максимально быстрый запуск
 серверный джит - заточен на скорость выполнения, оптимальнее
 оптимизации:
  1)устранение мертвого кода
  2) вывод вычислений из цикла
  for (int i=0; i<10000000; i++) {
    int k=5+10;
    }
  3) удалене общих подвыражений, свертка констант, движение кода
  4) устранение проверки корректности границ массива
  5) оптимизируются циклы, мб развернуты

включение режима печати результата:
-XX:+PrintCompilation время compilationId flag
b - blockingCompiler - заблокировано ... при клиентском компиляторе
* n - generatingNativeWrapper -
% - on stack replacement
! - methodHasExceptionHandlers
s - syncronizedMethod
class::method не увидим перегруженные методы
размер байт кода метода

LogCompilation: -XX+LogCompilation